<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Nancy-Lady</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Nancy-Lady">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Nancy-Lady">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Nancy-Lady">
  
    <link rel="alternative" href="/atom.xml" title="Nancy-Lady" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/logo.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/logo.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">楠城浅梦</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/cnjy" title="github">github</a>
					        
								<a class="mail" target="_blank" href="/664205296@qq.com" title="mail">mail</a>
					        
								<a class="weibo" target="_blank" href="https://weibo.com/u/5386925934" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/ECMA6/" style="font-size: 10px;">ECMA6</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">楠城浅梦</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">楠城浅梦</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/cnjy" title="github">github</a>
			        
						<a class="mail" target="_blank" href="/664205296@qq.com" title="mail">mail</a>
			        
						<a class="weibo" target="_blank" href="https://weibo.com/u/5386925934" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Ajax工作原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/31/Ajax工作原理/" class="article-date">
  	<time datetime="2017-12-31T06:31:18.000Z" itemprop="datePublished">2017-12-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/31/Ajax工作原理/">
        Ajax工作原理
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div><br>        <div class="markdown_views"><h1 id="ajax工作原理">Ajax工作原理</h1><br><br><p>　　在写这篇文章之前，曾经写过一篇关于AJAX技术的随笔，不过涉及到的方面很窄，对AJAX技术的背景、原理、优缺点等各个方面都很少涉及null。这次写这篇文章的背景是因为公司需要对内部程序员做一个培训。项目经理找到了我，并且征询我培训的主题，考虑到之前Javascript、CSS等WEB开发技术都已经讲解过了，所以决定针对AJAX这一块做一个比较系统的培训，所以这篇文章实际上是一个培训的材料。</p><br><br><p>　　在这篇文章中，我将从10个方面来对AJAX技术进行系统的讲解。</p><br><br><p>1、ajax技术的背景</p><br><br><p>　　不可否认，ajax技术的流行得益于google的大力推广，正是由于google earth、google suggest以及gmail等对ajax技术的广泛应用，催生了ajax的流行。而这也让微软感到无比的尴尬，因为早在97年，微软便已经发明了ajax中的关键技术，并且在99年IE5推出之时，它便开始支持XmlHttpRequest对象，并且微软之前已经开始在它的一些产品中应用ajax，比如说MSDN网站菜单中的一些应用。遗憾的是，不知道出于什么想法，当时微软发明了ajax的核心技术之后，并没有看到它的潜力而加以发展和推广，而是将它搁置起来。对于这一点来说，我个人是觉得非常奇怪的，因为以微软的资源和它的战略眼光来说，应该不会看不到ajax技术的前景，唯一的解释也许就是因为当时它的主要竞争对手Netscape的消失反而使它变得麻痹和迟钝，毕竟巨人也有打盹的时候，比如IBM曾经在对微软战略上的失误。正是这一次的失误，成就了它现在的竞争对手google在ajax方面的领先地位，而事实上google目前在ajax技术方面的领先是微软所无法达到的，这一点在后面我讲述ajax缺陷的时候也会提到。现在微软也意识到了这个问题，因此它也开始在ajax领域奋起直追，比如说推出它自己的ajax框架atlas，并且在.NET2.0也提供了一个用来实现异步回调的接口，即ICallBack接口。那么微软为什么对自己在ajax方面的落后如此紧张呢？现在就让我们来分析一下ajax技术后面隐藏的深刻意义。</p><br><br><p>2、ajax技术的意义</p><br><br><p>　　我们在平时的开发中都多多少少的接触或者应用到了ajax，谈到ajax技术的意义，我们关注得最多的毫无疑问是提升用户的体验。但是，如果我们结合将来电脑和互联网的发展趋势，我们会发现ajax技 术在某些方面正好代表了这种趋势。为什么这样说呢？我们知道，自从电脑出现以来，一直是桌面软件占据着绝对主导的地位，但是互联网的出现和成功使这一切开 始发生着微妙的变化。相当一部分的人都相信，迟早有一天，数据和电脑软件将会从桌面转移到互联网。也就是说，将来的电脑有可能抛弃笨重的硬盘，而直接从互 联网来获取数据和服务，我记得我念大学的时候，有位教授给我们上课的时候，曾经设想过这样一种情景，也许在将来的电脑桌面上，没有任何多余的软件和程序， 而仅仅只有一个IE，虽然现在看起来我们距离这一天还很遥远，并且这其中还有很多的问题需要解决，但是我觉得这个并非梦想，而是迟早将实现的现实。那么，这其中的主要问题就是互联网的连接不稳定，谁也不愿意看着自己的电脑从服务器一点一滴的下载数据，那么，ajax是不是解决了这个问题呢，说实话，与其说ajax解决了这个问题，倒不如它只是掩盖了这个问题，它只是在服务器和客户端之间充当了一个缓冲器，让用户误以为服务没有中断。精确的说，ajax并不能提高从服务器端下载数据的速度，而只是使这个等待不那么令人沮丧。但是正是这一点就足以产生巨大的影响和震动，它实际上也对桌面软件产生了巨大的冲击。这一点我用一个例子来说明，我们可以比较一下Outlook Express和Gmail，前者是典型的桌面软件，后者是ajax所实现的B/S模式，实际上后者目前已经在慢慢取代前者了，Gmail在收发邮件的时候已经和Outlook Express的功能几乎没有差别了，而且它不需要安装客户端程序。这就是为什么微软对ajax所带来的冲击有着如此的恐惧心理，并且在它前不久所进行的调查之中，将google看做他们未来十年内的主要竞争对手的主要原因之一。当然，这种变化也并不会将桌面软件全部淘汰，现有的浏览器还没有一个能像PhotoShop等桌面程序那样处理复杂的图像。但是我们也不能忽视它带来的影响和冲击。</p><br><br><p>3、关于ajax的名字</p><br><br><p>　　ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。</p><br><br><p>4、关于同步和异步</p><br><br><p>　　异步传输是面向字符的传输，它的单位是字符；而同步传输是面向比特的传输，它的单位是桢，它传输的时候要求接受方和发送方的时钟是保持一致的。 <br><br>　　具体来说，异步传输是将比特分成小组来进行传送。一般每个小组是一个8位字符，在每个小组的头部和尾部都有一个开始位和一个停止位，它在传送过程中接收方和发送方的时钟不要求一致，也就是说，发送方可以在任何时刻发送这些小组，而接收方并不知道它什么时候到达。一个最明显的例子就是计算机键盘和主机的通信，按下一个键的同时向主机发送一个8比特位的ASCII代 码，键盘可以在任何时刻发送代码，这取决于用户的输入速度，内部的硬件必须能够在任何时刻接收一个键入的字符。这是一个典型的异步传输过程。异步传输存在 一个潜在的问题，即接收方并不知道数据会在什么时候到达。在它检测到数据并做出响应之前，第一个比特已经过去了。这就像有人出乎意料地从后面走上来跟你说 话，而你没来得及反应过来，漏掉了最前面的几个词。因此，每次异步传输的信息都以一个起始位开头，它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间；在传输结束时，一个停止位表示该次传输信息的终止。按照惯例，空闲（没有传送数据）的线路实际携带着一个代表二进制1的信号。步传输的开始位使信号变成0，其他的比特位使信号随传输的数据信息而变化。最后，停止位使信号重新变回1，该信号一直保持到下一个开始位到达。例如在键盘上数字“1”，按照8比特位的扩展ASCII编码，将发送“00110001”，同时需要在8比特位的前面加一个起始位，后面一个停止位。 <br><br>　　同步传输的比特分组要大得多。它不是独立地发送每个字符，每个字符都有自己的开始位和停止位，而是把它们组合起来一起发送。我们将这些组合称为数据帧，或简称为帧。 <br><br>    　　数据帧的第一部分包含一组同步字符，它是一个独特的比特组合，类似于前面提到的起始位，用于通知接收方一个帧已经到达，但它同时还能确保接收方的采样速度和比特的到达速度保持一致，使收发双方进入同步。 <br><br>    　　帧的最后一部分是一个帧结束标记。与同步字符一样，它也是一个独特的比特串，类似于前面提到的停止位，用于表示在下一帧开始之前没有别的即将到达的数据了。 <br><br>    　　同步传输通常要比异步传输快速得多。接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们。另外，同步传输的开销也比较少。例如，一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多。随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少。但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小。另外，帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久。 <br><br>       了解了同步和异步的概念之后，大家应该对ajax为什么可以提升用户体验应该比较清晰了，它是利用异步请求方式的。打个比方，如果现在你家里所在的小区因 某种情况而面临停水，现在有关部门公布了两种方案，一是完全停水8个小时，在这8个小时内完全停水，8个小时后恢复正常。二是不完全停水10 个小时，在这10个小时内水没有完全断，只是流量比原来小了很多，在10个小时后恢复正常流量，那么，如果是你你会选择哪种方式呢？显然是后者。</p><br><br><p>5、ajax所包含的技术</p><br><br><p>　　大家都知道ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成。 <br><br>      　　 1.使用CSS和XHTML来表示。 <br><br>       　　2.使用DOM模型来交互和动态显示。 <br><br>       　　3.使用XMLHttpRequest来和服务器进行异步通信。 <br><br>       　　4.使用javascript来绑定和调用。 <br><br>        　　在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。</p><br><br><p>6、ajax原理和XmlHttpRequest对象</p><br><br><p>　　Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 <br><br>        XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 <br><br>      　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。 <br><br>      　首先，我们先来看看XMLHttpRequest这个对象的属性。 <br><br>      　　它的属性有： <br><br>          　　onreadystatechange  每次状态改变所触发事件的事件处理程序。 <br><br>          　　responseText     从服务器进程返回数据的字符串形式。 <br><br>          　　responseXML    从服务器进程返回的DOM兼容的文档数据对象。 <br><br>          　　status         从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） <br><br>      　　status Text       伴随状态码的字符串信息 <br><br>      　　readyState       对象状态值 <br><br>        　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） <br><br>        　　　　1 (初始化) 对象已建立，尚未调用send方法 <br><br>        　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知 <br><br>        　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， <br><br>        　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</p><br><br><p>　　但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。</p><br><br><pre><code>function CreateXmlHttp() {<br><br>//非IE浏览器创建XmlHttpRequest对象<br>if (window.XmlHttpRequest) {<br>    xmlhttp = new XmlHttpRequest();<br>}<br><br>//IE浏览器创建XmlHttpRequest对象<br>if (window.ActiveXObject) {<br>    try {<br>        xmlhttp = new ActiveXObject(“Microsoft.XMLHTTP”);<br>    }<br>    catch (e) {<br>        try {<br>            xmlhttp = new ActiveXObject(“msxml2.XMLHTTP”);<br>        }<br>        catch (ex) { }<br>    }<br>}<br>}<br></code></pre><br><br><hr><br><br><pre><code>function Ustbwuyi() {<br><br>var data = document.getElementById(“username”).value;<br>CreateXmlHttp();<br>if (!xmlhttp) {<br>    alert(“创建xmlhttp对象异常！”);<br>    return false;<br>}<br><br>xmlhttp.open(“POST”, url, false);<br><br>xmlhttp.onreadystatechange = function () {<br>    if (xmlhttp.readyState == 4) {<br>        document.getElementById(“user1”).innerHTML = “数据正在加载…”;<br>        if (xmlhttp.status == 200) {<br>            document.write(xmlhttp.responseText);<br>        }<br>    }<br>}<br>xmlhttp.send();<br>}<br></code></pre><br><br><p>　　如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus=4），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（status=200），那么就执行下面需要的操作。 <br><br>对于XmlHttpRequest的两个方法，open和send，其中open方法指定了： <br><br>a、向服务器提交数据的类型，即post还是get。 <br><br>b、请求的url地址和传递的参数。 <br><br>      c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。 <br><br>    Send方法用来发送请求。</p><br><br><p>　　知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。 <br><br>　　现在，我们对ajax的原理大概可以有一个了解了。我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。</p><br><br><p>7、ajax的优点</p><br><br><p>Ajax的给我们带来的好处大家基本上都深有体会，在这里我只简单的讲几点： <br><br>    1、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。 <br><br>　 2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。 <br><br>　 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 <br><br>    4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p><br><br><p>8、ajax的缺点</p><br><br><p>　　下面我着重讲一讲ajax的缺陷，因为平时我们大多注意的都是ajax给我们所带来的好处诸如用户体验的提升。而对ajax所带来的缺陷有所忽视。 <br><br>　　下面所阐述的ajax的缺陷都是它先天所产生的。 <br><br>   　1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。） <br><br>但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。 <br><br>     2、安全问题 <br><br>技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 <br><br>     3、对搜索引擎的支持比较弱。 <br><br>     4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 <br><br>     5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 <br><br>     6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。</p><br><br><p>9、ajax的几种框架</p><br><br><p>　　目前我们采用的比较多的ajax框架主要有ajax.dll,ajaxpro.dll,magicajax.dll 以及微软的atlas框架。Ajax.dll和Ajaxpro.dll这两个框架差别不大，而magicajax.dll只是封装得更厉害一些，比如说它可以直接返回DataSet数据集，前面我们已经说过，ajax返回的都是字符串，magicajax只是对它进行了封装而已。但是它的这个特点可以给我们带来很大的方便，比如说我们的页面有一个列表，而列表的数据是不断变化的，那么我们可以采用magicajax来处理，操作很简单，添加magicajax之后，将要更新的列表控件放在magicajax的控件之内，然后在pageload里面定义更新间隔的时间就ok了，atlas的原理和magicajax差不多。但是，需要注意的一个问题是，这几种框架都只支持IE，没有进行浏览器兼容方面的处理，用反编译工具察看他们的代码就可以知道。 <br><br> 除了这几种框架之外，我们平时用到的比较多的方式是自己创建xmlHttpRequest对象，这种方式和前面的几种框架相比更具有灵活性。另外，在这里还提一下aspnet2.0自带的异步回调接口，它和ajax一样也可以实现局部的无刷新，但它的实现实际上也是基于xmlhttprequest对象的，另外也是只支持IE，当然这是微软的一个竞争策略。</p><br><br><p>10、ajax示例</p><br><br><p>验证用户名是否注册。 <br><br>采用两种方式 <br><br>　　1 ajax.dll <br><br>　　2 自己写xmlhttprequest对象</p><br><br><p>10.ajax中常见到的一些错误 <br><br> 　　1 配置的问题</p><br><br><p>　　在pageload里面配置该页面的时候</p><br><br><p>11 <br><br>　　在后台调用的方法里调用了前台的部分…</p><br><br><pre><code>　　此文要感谢：<a href="http://www.cnblogs.com/ustbwuyi/archive/2007/02/08/645061.html#2215165" target="_blank" rel="noopener">http://www.cnblogs.com/ustbwuyi/archive/2007/02/08/645061.html#2215165</a><br></code></pre></div><br>        <script type="text/javascript"><br>            $(function () {<br>                $(‘pre.prettyprint code’).each(function () {<br>                    var lines = $(this).text().split(‘\n’).length;<br>                    var $numbering = $(‘<ul/>‘).addClass(‘pre-numbering’).hide();<br>                    $(this).addClass(‘has-numbering’).parent().append($numbering);<br>                    for (i = 1; i &lt;= lines; i++) {<br>                        $numbering.append($(‘<li/>‘).text(i));<br>                    };<br>                    $numbering.fadeIn(1700);<br>                });<br>            });<br>        </script><br><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/">ajax</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-ECMA6轻松入门" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/31/ECMA6轻松入门/" class="article-date">
  	<time datetime="2017-12-31T06:18:28.000Z" itemprop="datePublished">2017-12-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/31/ECMA6轻松入门/">
        ECMA6轻松入门
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <div><br>        <div class="markdown_views"><p></p><section class="post-content"> <br><br>        <h1 id="ecma6"><a name="t0" target="_blank"></a>ECMA6</h1></section><p></p><br><br><h2 id="1-什么是ecma6"><a name="t1" target="_blank"></a>1. 什么是ECMA6</h2><br><br><p>ECMAScript 6.0（简称 ES6）是 JavaScript 语言的下一代标准，在2015年6月正式发布。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><br><br><h2 id="2-ecmascript-和-javascript-的关系"><a name="t2" target="_blank"></a>2. ECMAScript 和 JavaScript 的关系</h2><br><br><p>ECMAScript是JavaScript的规格，JavaScript是ECMAScript的一种实现。日常场合，这两个词是可以互换的。<br><br>另外，ActionScript也是 ECMAScript的实现</p><br><br><p>1996年11月，JavaScript 的创造者 网景公司，将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。</p><br><br><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有网景公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被网景公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是网景，这样有利于保证这门语言的开放性和中立性。</p><br><br><h2 id="3-ecma2015"><a name="t3" target="_blank"></a>3. ECMA2015</h2><br><br><p>ES6 的第一个版本，在2015年6月发布，正式名称是《ECMAScript 2015标准》（简称 ES2015）。<br><br>2016年6月，小幅修订的《ECMAScript 2016标准》（简称 ES2016）发布，这个版本可以看作是 ES6.1 版。<br><br>2017年6月会发布 ES2017 标准。</p><br><br><p>因此，ES6 既是一个历史名词，也是一个泛指，含义是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等等，而ES2015 则是正式名称，特指该年发布的正式版本的语言标准。</p><br><br><h2 id="4-es6的兼容性问题"><a name="t4" target="_blank"></a>4. ES6的兼容性问题</h2><br><br><p>目前各大浏览器对ES6的支持度已经越来越高了，超过90%的 ES6 语法特性都实现了。<br><br>具体可参考 <a href="http://kangax.github.io/compat-table/es6/" target="_blank">http://kangax.github.io/compat-table/es6/</a> 查看各大浏览器的最新版本对ES6的支持情况</p><br><br><p>nodejs 微信开发 完全支持ES6的语法</p><br><br><h2 id="5-babel-转码器"><a name="t5" target="_blank"></a>5. Babel 转码器</h2><br><br><p>该转码器可以吧ES6语法转码为ES5语法，意味着，可以借助于Babel转码器提高ES6的兼容性。</p><br><br><h1 id="es6常用语法"><a name="t6" target="_blank"></a>ES6常用语法</h1><br><br><h2 id="1-变量扩展"><a name="t7" target="_blank"></a>1. 变量扩展</h2><br><br><h4 id="11-let-关键字"><a name="t8" target="_blank"></a>1.1. let 关键字</h4><br><br><p>用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效</p><br><br><pre><code>{<br>  let a = 10;<br>  var b = 1;<br>}<br><br>a // ReferenceError: a is not defined.<br>b // 1<br></code></pre><br><br><p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令</p><br><br><pre><code>for (let i = 0; i &lt; 10; i++) {}<br><br>console.log(i);<br>//ReferenceError: i is not defined<br></code></pre><br><br><p>不存在变量提升</p><br><br><pre><code>// var 的情况<br>console.log(foo); // 输出undefined<br>var foo = 2;<br><br>// let 的情况<br>console.log(bar); // 报错ReferenceError<br>let bar = 2;<br></code></pre><br><br><p>不允许重复声明</p><br><br><pre><code>let a = 100;<br>let a = 200; //报错<br><br>let b = 100;<br>b = 200; //正确<br></code></pre><br><br><h4 id="12-const-关键字"><a name="t9" target="_blank"></a>1.2 const 关键字</h4><br><br><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p><br><br><pre><code>const PI = 3.1415;<br>PI // 3.1415<br><br>PI = 3; //报错<br></code></pre><br><br><p>同，let一样，也不存在变量提升</p><br><br><h4 id="13-顶层对象和全局变量"><a name="t10" target="_blank"></a>1.3 顶层对象和全局变量</h4><br><br><p>ES6中将顶层对象(浏览器中是window对象，node中是Global对象)与全局变量不再挂钩。<br><br>但是，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。</p><br><br><h2 id="2-对象的简化写法"><a name="t11" target="_blank"></a>2. 对象的简化写法</h2><br><br><h4 id="21-属性的简化写法"><a name="t12" target="_blank"></a>2.1 属性的简化写法</h4><br><br><pre><code>var foo = ‘name1’;<br>var bar = ‘name2’;<br><br>var obj = {foo,bar};<br>//等同于<br>var obj = {foo:foo, bar:bar}<br></code></pre><br><br><h4 id="22-方法的简化写法"><a name="t13" target="_blank"></a>2.2 方法的简化写法</h4><br><br><pre><code>{<br>    fn:function(){<br>    }<br>}<br>//可简化为<br>{<br>    fn(){<br>    }<br>}<br></code></pre><br><br><h2 id="3-变量解构赋值"><a name="t14" target="_blank"></a>3. 变量解构赋值</h2><br><br><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><br><br><h4 id="31-数组的解构赋值"><a name="t15" target="_blank"></a>3.1 数组的解构赋值</h4><br><br><p>以前，变量赋值，只能这么写</p><br><br><pre><code>var a = 1;<br>var b = 2;<br>var c = 3;<br></code></pre><br><br><p>现在，也可以这么写</p><br><br><pre><code>let [a, b, c] = [1, 2, 3];<br></code></pre><br><br><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p><br><br><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p><br><br><pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];<br>foo // 1<br>bar // 2<br>baz // 3<br><br>let [ , , third] = [“foo”, “bar”, “baz”];<br>third // “baz”<br><br>let [x, , y] = [1, 2, 3];<br>x // 1<br>y // 3<br><br>let [head, …tail] = [1, 2, 3, 4];<br>head // 1<br>tail // [2, 3, 4]<br><br>let [x, y, …z] = [‘a’];<br>x // “a”<br>y // undefined<br>z // []<br></code></pre><br><br><p>如果解构不成功，变量的值就等于undefined<br><br>如果等号左边的形式是数组，而右边不是数组，将会报错</p><br><br><p>解构变量可以有默认值</p><br><br><pre><code>let [foo = true] = [];<br>foo // true<br><br>let [x, y = ‘b’] = [‘a’]; // x=’a’, y=’b’<br>let [x, y = ‘b’] = [‘a’, undefined]; // x=’a’, y=’b’<br></code></pre><br><br><h4 id="32-对象的解构"><a name="t16" target="_blank"></a>3.2 对象的解构</h4><br><br><p>解构不仅可以用于数组，还可以用于对象</p><br><br><pre><code>let { foo, bar } = { foo: “aaa”, bar: “bbb” };<br>foo // “aaa”<br>bar // “bbb”<br></code></pre><br><br><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><br><br><p>如果变量名与属性名不一致，必须写成下面这样。<br><br>var { foo: baz } = { foo: ‘aaa’, bar: ‘bbb’ };<br><br>baz // “aaa”</p><br><br><pre><code>let obj = { first: ‘hello’, last: ‘world’ };<br>let { first: f, last: l } = obj;<br>f // ‘hello’<br>l // ‘world’<br></code></pre><br><br><p>这实际上说明，对象的解构赋值是下面形式的简写</p><br><br><pre><code>let { foo: foo, bar: bar } = { foo: “aaa”, bar: “bbb” };<br></code></pre><br><br><p>和数组一样，解构也可以用于嵌套解构的对象</p><br><br><pre><code>let obj = {<br>  p: [<br>    ‘Hello’,<br>    { y: ‘World’ }<br>  ]<br>};<br><br>let { p: [x, { y }] } = obj;<br>x // “Hello”<br>y // “World”<br></code></pre><br><br><p>注意，这时p是模式，不是变量，因此不会被赋值。</p><br><br><p>对象的解构也可以指定默认值</p><br><br><pre><code>var {x, y = 5} = {x: 1};<br>x // 1<br>y // 5<br><br>var { message: msg = ‘Something went wrong’ } = {};<br>msg // “Something went wrong”<br></code></pre><br><br><h4 id="33-特殊对象的解构"><a name="t17" target="_blank"></a>3.3 特殊对象的解构</h4><br><br><p>JavaScript中一切皆对象，向字符串、布尔值、数值都可以被解构，而且字符串可以当做字符组成的数组</p><br><br><pre><code>const [a, b, c, d, e] = ‘hello’;<br>a // “h”<br>b // “e”<br>c // “l”<br>d // “l”<br>e // “o”<br><br>let {length : len} = ‘hello’;   //因为字符串具有属性length<br>len // 5<br><br>let {toString: s} = 123;<br>s === Number.prototype.toString // true<br></code></pre><br><br><h4 id="34-实际用途"><a name="t18" target="_blank"></a>3.4 实际用途</h4><br><br><p>交换变量的值</p><br><br><pre><code>let x = 1;<br>let y = 2;<br><br>[x, y] = [y, x];<br></code></pre><br><br><p>提取JSON数据</p><br><br><pre><code>let jsonData = {<br>  id: 42,<br>  status: “OK”,<br>  data: [867, 5309]<br>};<br><br>let { id, status, data: number } = jsonData;<br><br>console.log(id, status, number);<br>// 42, “OK”, [867, 5309]<br></code></pre><br><br><p>函数参数的默认值</p><br><br><pre><code>jQuery.ajax = function (url, {<br>  async = true,<br>  beforeSend = function () {},<br>  cache = true,<br>  complete = function () {},<br>  crossDomain = false,<br>  global = true,<br>  // … more config<br>}) {<br>  // … do stuff<br>};<br></code></pre><br><br><p>输入模块的指定方法</p><br><br><pre><code>const { SourceMapConsumer, SourceNode } = require(“source-map”);<br></code></pre><br><br><h2 id="4-扩展运算符"><a name="t19" target="_blank"></a>4. 扩展运算符（…）</h2><br><br><p>扩展运算符（…）可以将某些数据结构转为数组。<br><br>可以将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><br><br><pre><code>// arguments对象<br>function foo() {<br>  var args = […arguments];<br>}<br><br>// NodeList对象<br>[…document.querySelectorAll(‘div’)]<br></code></pre><br><br><h2 id="5-forof-循环"><a name="t20" target="_blank"></a>5. for…of 循环</h2><br><br><p>ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。<br><br>for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）以及字符串</p><br><br><pre><code>const arr = [‘red’, ‘green’, ‘blue’];<br><br>for(let v of arr) {<br>  console.log(v); // red green blue<br>}<br></code></pre><br><br><h2 id="6-class关键字"><a name="t21" target="_blank"></a>6. Class关键字</h2><br><br><h4 id="61-定义类"><a name="t22" target="_blank"></a>6.1 定义类</h4><br><br><pre><code>function Point(x, y) {<br>  this.x = x;<br>  this.y = y;<br>}<br><br>Point.prototype.toString = function () {<br>  return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>};<br><br>var p = new Point(1, 2);<br></code></pre><br><br><p>JS传统方法中定义对象是通过构造函数，这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。</p><br><br><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。</p><br><br><pre><code>class Bar {<br>  doStuff() {<br>    console.log(‘stuff’);<br>  }<br>}<br><br>var b = new Bar();<br>b.doStuff() // “stuff”<br></code></pre><br><br><p>如果你了解过Java或者PHP或者C++或者.net 你将会对这种写法非常熟悉</p><br><br><h4 id="62-constructor-构造方法"><a name="t23" target="_blank"></a>6.2 constructor 构造方法</h4><br><br><pre><code>class Bar{<br>    constructro() {<br><br>    }<br>}<br></code></pre><br><br><p>在类被实例化的时候， 构造函数会被自动调用</p><br><br><h4 id="63-extends-继承"><a name="t24" target="_blank"></a>6.3 extends 继承</h4><br><br><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p><br><br><pre><code>class ColorPoint extends Point {}<br></code></pre><br><br><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。</p><br><br><h4 id="64-super"><a name="t25" target="_blank"></a>6.4 super</h4><br><br><pre><code>class ColorPoint extends Point {<br>  constructor(x, y, color) {<br>    super(x, y); // 调用父类的constructor(x, y)<br>    this.color = color;<br>  }<br><br>  toString() {<br>    return this.color + ‘ ‘ + super.toString(); // 调用父类的toString()<br>  }<br>}<br></code></pre><br><br><p>上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。</p><br><br><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p><br><br><h2 id="7-箭头函数"><a name="t26" target="_blank"></a>7. 箭头函数</h2><br><br><p>ES6允许使用“箭头”（=&gt;）定义函数。</p><br><br><pre><code>var f = v =&gt; v;<br>//等同于<br>var f = function(v) {<br>  return v;<br>};<br><br>var f = () =&gt; 5;<br>// 等同于<br>var f = function () { return 5 };<br><br>var sum = (num1, num2) =&gt; num1 + num2;<br>// 等同于<br>var sum = function(num1, num2) {<br>  return num1 + num2;<br>};<br></code></pre><br><br><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p><br><br><pre><code>var sum = (num1, num2) =&gt; {<br>    let sum =  num1 + num2;<br>    return sum;<br>}<br></code></pre><br><br><p>箭头函数的一个用处是简化回调函数<br><br>// 正常函数写法<br><br>var result = values.sort(function (a, b) {<br><br>return a - b;<br><br>});</p><br><br><pre><code>// 箭头函数写法<br>var result = values.sort((a, b) =&gt; a - b);<br></code></pre><br><br><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p><br><br><pre><code>function foo() {<br>  setTimeout(() =&gt; {<br>    console.log(‘id:’, this.id);<br>  }, 100);<br>}<br><br>var id = 21;<br><br>foo.call({ id: 42 });<br>// id: 42<br></code></pre><br><br><p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p><br><br><p>箭头函数 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p><br><br><p>箭头函数 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p><br><br><h2 id="8-es6函数参数问题"><a name="t27" target="_blank"></a>8. ES6函数参数问题</h2><br><br><h4 id="81-函数默认值"><a name="t28" target="_blank"></a>8.1 函数默认值</h4><br><br><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。不必那ES5那样，采用些特殊手段</p><br><br><pre><code>//ES6写法<br>function log(x, y = ‘World’) {<br>  console.log(x, y);<br>}<br><br>//ES5写法<br>function log(x, y) {<br>    if (y === undefined) {<br>        y = ‘World’;<br>    }<br>    console.log(x,y);<br>}<br></code></pre><br><br><h4 id="82-rest参数"><a name="t29" target="_blank"></a>8.2 rest参数</h4><br><br><p>ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了</p><br><br><pre><code>function add(…values) {<br>  let sum = 0;<br><br>  for (var val of values) {<br>    sum += val;<br>  }<br><br>  return sum;<br>}<br><br>add(2, 5, 3) // 10<br></code></pre><br><br><h2 id="9-模板字符串"><a name="t30" target="_blank"></a>9. 模板字符串</h2><br><br><p>传统的JavaScript语言，输出模板通常是这样写的。</p><br><br><pre><code>$(‘#result’).append(<br>  ‘There are &lt;b&gt;’ + basket.count + ‘&lt;/b&gt; ‘ +<br>  ‘items in your basket, ‘ +<br>  ‘&lt;em&gt;’ + basket.onSale +<br>  ‘&lt;/em&gt; are on sale!’<br>);<br></code></pre><br><br><p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题</p><br><br><pre><code>$(‘#result’).append(<code>There are &amp;lt;b&amp;gt;${basket.count}&amp;lt;/b&amp;gt; items
   in your basket, &amp;lt;em&amp;gt;${basket.onSale}&amp;lt;/em&amp;gt;
  are on sale!</code>);<br></code></pre><br><br><p>模板字符串（template string）是增强版的字符串，用反引号 <code>标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;

&lt;p&gt;模板字符串中嵌入变量，需要将变量名写在${}之中。&lt;br&gt;
大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;</code>User ${user.name} is not authorized to do ${action}.<code></code>${x} + ${y} = ${x + y}<code></code>foo ${fn()} bar`<br><br><br></p><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><br><br><h2 id="10-symbol"><a name="t31" target="_blank"></a>10. Symbol</h2><br><br><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）<br><br>Symbol值通过Symbol函数生成。<br><br>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><br><br><pre><code>let s = Symbol();<br><br>typeof s<br>// “symbol”<br><br>var s1 = Symbol(‘foo’);<br>var s2 = Symbol(‘bar’);<br><br>s1 // Symbol(foo)<br>s2 // Symbol(bar)<br><br>s1.toString() // “Symbol(foo)”<br>s2.toString() // “Symbol(bar)”<br></code></pre><br><br><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。</p><br><br><p>任意两个Symbol类型的数据都不想等</p><br><br><pre><code>// 没有参数的情况<br>var s1 = Symbol();<br>var s2 = Symbol();<br><br>s1 === s2 // false<br><br>// 有参数的情况<br>var s1 = Symbol(‘foo’);<br>var s2 = Symbol(‘foo’);<br><br>s1 === s2 // false<br></code></pre><br><br><p>Symbol值不能与其他类型的值进行运算，会报错。</p><br><br><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。<br><br>var mySymbol = Symbol();</p><br><br><pre><code>// 第一种写法<br>var a = {};<br>a[mySymbol] = ‘Hello!’;<br><br>// 第二种写法<br>var a = {<br>};<br><br>// 第三种写法<br>var a = {};<br>Object.defineProperty(a, mySymbol, { value: ‘Hello!’ });<br><br>// 以上写法都得到同样结果<br>a[mySymbol] // “Hello!”<br></code></pre><br><br><p>注意，Symbol值作为对象属性名时，不能用点运算符。</p><br><br><h2 id="11-set-数据结构"><a name="t32" target="_blank"></a>11. Set 数据结构</h2><br><br><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br><br>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><br><br><pre><code>const s = new Set();<br><br>[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));<br><br>for (let i of s) {<br>  console.log(i);<br>}<br>// 2 3 5 4<br></code></pre><br><br><p>上面代码通过add方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值</p><br><br><p>Set 函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。</p><br><br><pre><code>var set = new Set([1, 2, 3, 4, 4]);<br>[…set]<br>// [1, 2, 3, 4]<br><br>// 例二<br>var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br>items.size // 5<br></code></pre><br><br><h2 id="12-map-数据结构"><a name="t33" target="_blank"></a>12. Map 数据结构</h2><br><br><p>ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p><br><br><pre><code>var m = new Map();<br>var o = {p: ‘Hello World’};<br><br>m.set(o, ‘content’)<br>m.get(o) // “content”<br><br>m.has(o) // true<br>m.delete(o) // true<br>m.has(o) // false<br></code></pre><br><br><p>作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p><br><br><pre><code>var map = new Map([<br>  [‘name’, ‘张三’],<br>  [‘title’, ‘Author’]<br>]);<br><br>map.size // 2<br>map.has(‘name’) // true<br>map.get(‘name’) // “张三”<br>map.has(‘title’) // true<br>map.get(‘title’) // “Author”<br></code></pre><br><br><hr><br><br><p>以上介绍的是ES6中最为常用的也较为容易掌握一些新语法。 查看更为详细的ES6语法，请访问阮一峰老师 <a href="http://es6.ruanyifeng.com/" target="_blank">ECMAScript6入门</a></p><br><br><p>（完）</p><br><br><p></p></div><br>        <script type="text/javascript"><br>            $(function () {<br>                $(‘pre.prettyprint code’).each(function () {<br>                    var lines = $(this).text().split(‘\n’).length;<br>                    var $numbering = $(‘<ul/>‘).addClass(‘pre-numbering’).hide();<br>                    $(this).addClass(‘has-numbering’).parent().append($numbering);<br>                    for (i = 1; i &lt;= lines; i++) {<br>                        $numbering.append($(‘<li/>‘).text(i));<br>                    };<br>                    $numbering.fadeIn(1700);<br>                });<br>            });<br>        </script><br><br></div>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMA6/">ECMA6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/">es6</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Git的使用-将本地项目上传至github" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/28/Git的使用-将本地项目上传至github/" class="article-date">
  	<time datetime="2017-12-28T10:23:34.000Z" itemprop="datePublished">2017-12-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/Git的使用-将本地项目上传至github/">
        Git的使用-将本地项目上传至github
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>直奔主题，首先需要下载git，具体下载安装就不赘述了，附带git官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p>
<h2 id="一、本地创建本地文件夹"><a href="#一、本地创建本地文件夹" class="headerlink" title="一、本地创建本地文件夹"></a>一、本地创建本地文件夹</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;安装好git之后,现在本地创建一个空文件夹，并且进入该文件夹</p>
<pre><code>$ mkdir test      //创建文件夹
$ cd test       //进入当前目录
</code></pre><h2 id="二、执行git命令"><a href="#二、执行git命令" class="headerlink" title="二、执行git命令"></a>二、执行git命令</h2><p>&emsp;&emsp;1、通过git init命令让新建的文件夹成为git可管理的仓库</p>
<pre><code>$ git init
</code></pre><p> &emsp;&emsp;执行完这一步在test文件夹里就会看到.git文件夹，它是用来跟踪和管理版本库的，如果看不到说明.git文件是隐藏文件，解决办法，查看–&gt;勾选隐藏的文件，这样就可以看到了。接下来将本地项目放到这个文件夹里<br> <img src="http://img.blog.csdn.net/20171227204414366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p> &emsp;&emsp;2、执行git add .将项目添加到仓库</p>
<pre><code>$ git add .      //注意add后面有一个点，并且用空格分开
</code></pre><p>&emsp;&emsp;只要过程中不出现error提示，就都没什么问题，此时还可以通过git status 指令进行状态查看。<br><img src="http://img.blog.csdn.net/20171227205501022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&emsp;&emsp;3、执行git commit把项目提交到仓库</p>
<pre><code>$ git commit -m &quot;first commit&quot;
</code></pre><p>&emsp;&emsp;-m后面跟的是本次提交注释的内容，可以不写，但建议写上，不然容易报错，好了，到了这一步本地仓库创建就做好了，接下来就要连接github了<br><img src="http://img.blog.csdn.net/20171227210137273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="三、连接github"><a href="#三、连接github" class="headerlink" title="三、连接github"></a>三、连接github</h2><p>&emsp;&emsp;在连接github之前我想说的是，你首先要有github账号，并且SSH KEY是已经创建好了，因为git仓库和github仓库的连接是通过ssh加密的，还没有创建的同学可以Google一下，在这里就不详细说了，直接切入主题<br>&emsp;&emsp;1、创建github仓库，点击new创建<br><img src="http://img.blog.csdn.net/20171227210751274?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171227211054968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&emsp;&emsp;2、创建好github仓库后就是与git仓库的关联了，此时打开刚才那个命令框，执行</p>
<pre><code>$ git remote add origin https://github.com/cnjy/test.git
</code></pre><p>&emsp;&emsp;origin后面的地址位置<br><img src="http://img.blog.csdn.net/20171227211741454?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&emsp;&emsp;3、关联好之后就是讲文件push到github上了<br>&emsp;&emsp;如果github仓库的文件夹时空的执行</p>
<pre><code>$ git push -u origin master
</code></pre><p>&emsp;&emsp;等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了</p>
<pre><code>$ git push origin master
</code></pre><p>&emsp;&emsp;不过此时会有一个坑，如果我们在创建github仓库是勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），此时我们就需要执行接下来的一步</p>
<pre><code>$ git pull --rebase origin master
</code></pre><p>&emsp;&emsp; 执行完这一步再来一遍$ git push origin master就可以了<br><img src="http://img.blog.csdn.net/20171227212910642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&emsp;&emsp;  到这里就结束了，打开github就可以看到我们的项目就已经传到github上面了<br><img src="http://img.blog.csdn.net/20171227213124476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY25qeV8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>&emsp;&emsp;  只是总结了使用git将本地项目上传至github，想更好地使用git还需要进一步学习。<br>&emsp;&emsp; 附：<a href="https://github.com/cnjy" target="_blank" rel="noopener">https://github.com/cnjy</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/github/">github</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/28/hello-world/" class="article-date">
  	<time datetime="2017-12-28T06:54:12.999Z" itemprop="datePublished">2017-12-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/28/hello-world/">
        Hello World
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 楠城浅梦
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>